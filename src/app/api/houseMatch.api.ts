//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase, HttpContext } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IHouseMatch {
    /**
     * User list
     * @return OK
     */
    getUsers(): Observable<User[]>;
    /**
     * Create User
     * @param body Cuerpo del mensaje para crear el usuario.
     * @return OK
     */
    createUser(body: IdOutput): Observable<User[]>;
    /**
     * User list
     * @return OK
     */
    getUser(id: string): Observable<User>;
    /**
     * User update
     * @param body Cuerpo del mensaje para actualizar el usuario.
     * @return OK
     */
    updateUser(id: string, body: UserInput): Observable<BoolOutput>;
    /**
     * User delete
     * @return OK
     */
    deleteUser(id: string): Observable<BoolOutput>;
    /**
     * User with Role list
     * @return OK
     */
    getUserRoles(userID: string): Observable<UserRole[]>;
    /**
     * User Role list
     * @return OK
     */
    getUser2(userId: string, roleId: string): Observable<UserRole>;
    /**
     * User Role update
     * @return OK
     */
    assignmentUser(userId: string, roleId: string): Observable<IdOutput>;
    /**
     * User delete
     * @return OK
     */
    deleteUser2(userId: string, roleId: string): Observable<BoolOutput>;
    /**
     * Role list
     * @return OK
     */
    getRoles(): Observable<Role[]>;
    /**
     * Create Role
     * @param body Cuerpo del mensaje para crear el rol.
     * @return OK
     */
    createRole(body: RoleInput): Observable<IdOutput>;
    /**
     * Role list
     * @return OK
     */
    getRole(id: string): Observable<IdOutput>;
    /**
     * Role update
     * @param body Cuerpo del mensaje para actualizar el rol.
     * @return OK
     */
    updateRole(id: string, body: RoleInput): Observable<BoolOutput>;
    /**
     * Role delete
     * @return OK
     */
    deleteRole(id: string): Observable<BoolOutput>;
    /**
     * role with view list
     * @return OK
     */
    getRoleView(): Observable<UserRole[]>;
    /**
     * User Role update
     * @param body Cuerpo del mensaje para crear el role view.
     * @return OK
     */
    assignmentRoleView(body: RoleViewInput): Observable<IdOutput>;
    /**
     * RoleView update
     * @param body Cuerpo del mensaje para actualizar el role view.
     * @return OK
     */
    updateRoleView(body: RoleViewInput): Observable<BoolOutput>;
    /**
     * User Role list
     * @return OK
     */
    getUser3(roleId: string, viewID: string): Observable<UserRole>;
    /**
     * User delete
     * @return OK
     */
    deleteUser3(roleId: string, viewID: string): Observable<BoolOutput>;
    /**
     * Module list
     * @return OK
     */
    getModules(): Observable<Module[]>;
    /**
     * Create Module
     * @param body Cuerpo del mensaje para crear el module.
     * @return OK
     */
    createModule(body: ModuleInput): Observable<IdOutput>;
    /**
     * Module list
     * @return OK
     */
    getModule(id: string): Observable<Module>;
    /**
     * Module update
     * @param body Cuerpo del mensaje para actualizar el module.
     * @return OK
     */
    updateModule(id: string, body: ModuleInput): Observable<BoolOutput>;
    /**
     * Module delete
     * @return OK
     */
    deleteModule(id: string): Observable<BoolOutput>;
    /**
     * View list
     * @return OK
     */
    getViews(): Observable<View[]>;
    /**
     * Create View
     * @param body Cuerpo del mensaje para crear el view.
     * @return OK
     */
    createView(body: ViewInput): Observable<IdOutput>;
    /**
     * View list
     * @return OK
     */
    getView(id: string): Observable<View>;
    /**
     * View update
     * @param body Cuerpo del mensaje para actualizar el view.
     * @return OK
     */
    updateView(id: string, body: ViewInput): Observable<BoolOutput>;
    /**
     * View delete
     * @return OK
     */
    deleteView(id: string): Observable<BoolOutput>;
}

@Injectable({
    providedIn: 'root'
})
export class HouseMatch implements IHouseMatch {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:8080/v1";
    }

    /**
     * User list
     * @return OK
     */
    getUsers(httpContext?: HttpContext): Observable<User[]> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User[]>;
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as User[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create User
     * @param body Cuerpo del mensaje para crear el usuario.
     * @return OK
     */
    createUser(body: IdOutput, httpContext?: HttpContext): Observable<User[]> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User[]>;
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as User[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * User list
     * @return OK
     */
    getUser(id: string, httpContext?: HttpContext): Observable<User> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<User>;
                }
            } else
                return _observableThrow(response_) as any as Observable<User>;
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as User;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * User update
     * @param body Cuerpo del mensaje para actualizar el usuario.
     * @return OK
     */
    updateUser(id: string, body: UserInput, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoolOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoolOutput>;
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * User delete
     * @return OK
     */
    deleteUser(id: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoolOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoolOutput>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * User with Role list
     * @return OK
     */
    getUserRoles(userID: string, httpContext?: HttpContext): Observable<UserRole[]> {
        let url_ = this.baseUrl + "/userRole/users/{userID}";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined.");
        url_ = url_.replace("{userID}", encodeURIComponent("" + userID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRole[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRole[]>;
        }));
    }

    protected processGetUserRoles(response: HttpResponseBase): Observable<UserRole[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserRole[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * User Role list
     * @return OK
     */
    getUser2(userId: string, roleId: string, httpContext?: HttpContext): Observable<UserRole> {
        let url_ = this.baseUrl + "/userRole/user/{userId}/role/{roleId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRole>;
        }));
    }

    protected processGetUser2(response: HttpResponseBase): Observable<UserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserRole;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * User Role update
     * @return OK
     */
    assignmentUser(userId: string, roleId: string, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + "/userRole/user/{userId}/role/{roleId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignmentUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignmentUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdOutput>;
        }));
    }

    protected processAssignmentUser(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * User delete
     * @return OK
     */
    deleteUser2(userId: string, roleId: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + "/userRole/user/{userId}/role/{roleId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoolOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoolOutput>;
        }));
    }

    protected processDeleteUser2(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Role list
     * @return OK
     */
    getRoles(httpContext?: HttpContext): Observable<Role[]> {
        let url_ = this.baseUrl + "/roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Role[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Role[]>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<Role[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Role[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create Role
     * @param body Cuerpo del mensaje para crear el rol.
     * @return OK
     */
    createRole(body: RoleInput, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + "/roles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdOutput>;
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Role list
     * @return OK
     */
    getRole(id: string, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + "/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdOutput>;
        }));
    }

    protected processGetRole(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Role update
     * @param body Cuerpo del mensaje para actualizar el rol.
     * @return OK
     */
    updateRole(id: string, body: RoleInput, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + "/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoolOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoolOutput>;
        }));
    }

    protected processUpdateRole(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Role delete
     * @return OK
     */
    deleteRole(id: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + "/roles/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoolOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoolOutput>;
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * role with view list
     * @return OK
     */
    getRoleView(httpContext?: HttpContext): Observable<UserRole[]> {
        let url_ = this.baseUrl + "/roleView";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRole[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRole[]>;
        }));
    }

    protected processGetRoleView(response: HttpResponseBase): Observable<UserRole[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserRole[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * User Role update
     * @param body Cuerpo del mensaje para crear el role view.
     * @return OK
     */
    assignmentRoleView(body: RoleViewInput, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + "/roleView";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignmentRoleView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignmentRoleView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdOutput>;
        }));
    }

    protected processAssignmentRoleView(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * RoleView update
     * @param body Cuerpo del mensaje para actualizar el role view.
     * @return OK
     */
    updateRoleView(body: RoleViewInput, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + "/roleView";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRoleView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRoleView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoolOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoolOutput>;
        }));
    }

    protected processUpdateRoleView(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * User Role list
     * @return OK
     */
    getUser3(roleId: string, viewID: string, httpContext?: HttpContext): Observable<UserRole> {
        let url_ = this.baseUrl + "/roleView/role/{roleID}/view/{viewID}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (viewID === undefined || viewID === null)
            throw new Error("The parameter 'viewID' must be defined.");
        url_ = url_.replace("{viewID}", encodeURIComponent("" + viewID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserRole>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserRole>;
        }));
    }

    protected processGetUser3(response: HttpResponseBase): Observable<UserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserRole;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * User delete
     * @return OK
     */
    deleteUser3(roleId: string, viewID: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + "/roleView/role/{roleID}/view/{viewID}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (viewID === undefined || viewID === null)
            throw new Error("The parameter 'viewID' must be defined.");
        url_ = url_.replace("{viewID}", encodeURIComponent("" + viewID));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoolOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoolOutput>;
        }));
    }

    protected processDeleteUser3(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Module list
     * @return OK
     */
    getModules(httpContext?: HttpContext): Observable<Module[]> {
        let url_ = this.baseUrl + "/modules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModules(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModules(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Module[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Module[]>;
        }));
    }

    protected processGetModules(response: HttpResponseBase): Observable<Module[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Module[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create Module
     * @param body Cuerpo del mensaje para crear el module.
     * @return OK
     */
    createModule(body: ModuleInput, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + "/modules";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdOutput>;
        }));
    }

    protected processCreateModule(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Module list
     * @return OK
     */
    getModule(id: string, httpContext?: HttpContext): Observable<Module> {
        let url_ = this.baseUrl + "/modules/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Module>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Module>;
        }));
    }

    protected processGetModule(response: HttpResponseBase): Observable<Module> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Module;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Module update
     * @param body Cuerpo del mensaje para actualizar el module.
     * @return OK
     */
    updateModule(id: string, body: ModuleInput, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + "/modules/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoolOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoolOutput>;
        }));
    }

    protected processUpdateModule(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Module delete
     * @return OK
     */
    deleteModule(id: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + "/modules/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteModule(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteModule(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoolOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoolOutput>;
        }));
    }

    protected processDeleteModule(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * View list
     * @return OK
     */
    getViews(httpContext?: HttpContext): Observable<View[]> {
        let url_ = this.baseUrl + "/views";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetViews(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetViews(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<View[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<View[]>;
        }));
    }

    protected processGetViews(response: HttpResponseBase): Observable<View[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as View[];
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * Create View
     * @param body Cuerpo del mensaje para crear el view.
     * @return OK
     */
    createView(body: ViewInput, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + "/views";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IdOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IdOutput>;
        }));
    }

    protected processCreateView(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * View list
     * @return OK
     */
    getView(id: string, httpContext?: HttpContext): Observable<View> {
        let url_ = this.baseUrl + "/views/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<View>;
                }
            } else
                return _observableThrow(response_) as any as Observable<View>;
        }));
    }

    protected processGetView(response: HttpResponseBase): Observable<View> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as View;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * View update
     * @param body Cuerpo del mensaje para actualizar el view.
     * @return OK
     */
    updateView(id: string, body: ViewInput, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + "/views/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoolOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoolOutput>;
        }));
    }

    protected processUpdateView(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * View delete
     * @return OK
     */
    deleteView(id: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + "/views/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            context: httpContext,
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BoolOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BoolOutput>;
        }));
    }

    protected processDeleteView(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BadRequest;
            return throwException("BAD_REQUEST", status, _responseText, _headers, result400);
            }));
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result422: any = null;
            result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity;
            return throwException("UNPROCESSABLE_ENTITY", status, _responseText, _headers, result422);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result500: any = null;
            result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError;
            return throwException("INTERNAL_SERVER_ERROR", status, _responseText, _headers, result500);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface User {
    /** ID del usuario. */
    id?: string;
    /** Usuario o nick. */
    user?: string;
    /** Password del usuario. */
    password?: string;
    /** Email del usuario */
    email?: string;
    /** Tema de visualizacion del usuario */
    theme?: string;

    [key: string]: any;
}

export interface UserInput {
    /** Usuario o nick. */
    user?: string;
    /** Password del usuario. */
    password?: string;
    /** Email del usuario */
    email?: string;
    /** Tema de visualizacion del usuario */
    theme?: string;

    [key: string]: any;
}

export interface Module {
    /** id del modulo. */
    id?: string;
    /** name. */
    name?: string;
    /** description del modulo. */
    description?: string;
    /** icon del modulo */
    icon?: string;
    /** order de visualizacion del modulo */
    order?: string;

    [key: string]: any;
}

export interface ModuleInput {
    /** name. */
    name?: string;
    /** description del modulo. */
    description?: string;
    /** icon del modulo */
    icon?: string;
    /** order de visualizacion del modulo */
    order?: string;

    [key: string]: any;
}

export interface UserRole {
    user?: User;
    role?: Role;

    [key: string]: any;
}

export interface UserRoleInput {
    /** id del user. */
    userID?: string;
    /** id del role. */
    roleID?: string;

    [key: string]: any;
}

export interface Role {
    /** id del role. */
    id?: string;
    /** name. */
    name?: string;
    /** description del role. */
    description?: string;
    /** order de visualizacion del role */
    order?: string;

    [key: string]: any;
}

export interface RoleInput {
    /** name. */
    name?: string;
    /** description del role. */
    description?: string;
    /** order de visualizacion del role */
    order?: string;

    [key: string]: any;
}

export interface RoleView {
    role?: Role;
    view?: View;
    /** viewOrder. */
    viewOrder?: string;
    /** viewPosition del view. */
    viewPosition?: string;

    [key: string]: any;
}

export interface RoleViewInput {
    /** id del role. */
    roleID?: string;
    /** id de view. */
    viewID?: string;
    /** viewOrder. */
    viewOrder?: string;
    /** viewPosition del view. */
    viewPosition?: string;

    [key: string]: any;
}

export interface View {
    /** id del view. */
    id?: string;
    moduleId?: Module;
    /** name. */
    name?: string;
    /** description del view. */
    description?: string;
    /** url de visualizacion del view */
    url?: string;
    /** icon del view */
    icon?: string;

    [key: string]: any;
}

export interface ViewInput {
    /** name. */
    name?: string;
    /** description del view. */
    description?: string;
    /** url de visualizacion del view */
    url?: string;
    /** icon del view */
    icon?: string;

    [key: string]: any;
}

export interface IdOutput {
    /** ID. */
    id?: string;

    [key: string]: any;
}

export interface BoolOutput {
    /** boolean response. */
    id?: boolean;

    [key: string]: any;
}

/** Object of response error */
export interface UnexpectedError {
    /** custom code of response */
    code?: string;
    /** message of response */
    message?: string;

    [key: string]: any;
}

/** Object of response error */
export interface BadRequest {
    /** custom code of response */
    code?: string;
    /** message of response */
    message?: string;
    details?: EntityDetail[];

    [key: string]: any;
}

/** Object of response error */
export interface UnprocessableEntity {
    /** custom code of response */
    code?: string;
    /** message of response */
    message?: string;
    details?: EntityDetail[];

    [key: string]: any;
}

/** Object of response error */
export interface EntityDetail {
    /** field with error */
    field?: string;
    /** custom code of response */
    issue?: string;
    /** error details of field */
    description?: string;

    [key: string]: any;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}