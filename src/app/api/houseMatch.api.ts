//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { HttpClient, HttpContext, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { Observable, of as _observableOf, throwError as _observableThrow } from 'rxjs';
import { catchError as _observableCatch, mergeMap as _observableMergeMap } from 'rxjs/operators';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IHouseMatch {
    /**
     * Login
     * @param body Cuerpo del mensaje para acceder al sistema.
     * @return OK
     */
    login(body: Login): Observable<Token>;
    /**
     * upload multimedia
     * @param fileUpload (optional)
     * @return OK
     */
    uploadMedia(fileUpload?: FileParameter | undefined): Observable<IdOutput>;
    /**
     * see multimedia
     * @param filename nombre del archivo multimedia
     * @return OK
     */
    seeFiles(filename: string): Observable<FileResponse>;
    /**
     * User list
     * @return OK
     */
    getUsers(): Observable<UserSecondLevel[]>;
    /**
     * Create User
     * @param body Cuerpo del mensaje para crear el usuario.
     * @return OK
     */
    createUser(body: UserInput): Observable<IdOutput>;
    /**
     * User list
     * @return OK
     */
    getUser(id: string): Observable<UserSecondLevel>;
    /**
     * User update
     * @param body Cuerpo del mensaje para actualizar el usuario.
     * @return OK
     */
    updateUser(id: string, body: UserInput): Observable<BoolOutput>;
    /**
     * User delete
     * @return OK
     */
    deleteUser(id: string): Observable<BoolOutput>;
    /**
     * Users list with roles
     * @return OK
     */
    getUsersWithRoles(): Observable<UserWithRoles[]>;
    /**
     * Person list
     * @return OK
     */
    getPersons(): Observable<PersonSecondLevel[]>;
    /**
     * Create Person
     * @param body Cuerpo del mensaje para crear el usuario.
     * @return OK
     */
    createPerson(body: PersonInput): Observable<IdOutput>;
    /**
     * Person list
     * @return OK
     */
    getPerson(id: string): Observable<PersonSecondLevel>;
    /**
     * Person update
     * @param body Cuerpo del mensaje para actualizar el usuario.
     * @return OK
     */
    updatePerson(id: string, body: PersonInput): Observable<BoolOutput>;
    /**
     * Person delete
     * @return OK
     */
    deletePerson(id: string): Observable<BoolOutput>;
    /**
     * Create Person with location
     * @param body Cuerpo del mensaje para crear el person.
     * @return OK
     */
    createPersonLocation(body: PersonLocationCreateInput): Observable<IdOutput>;
    /**
     * Update Person with location
     * @param body Cuerpo del mensaje para crear el person.
     * @return OK
     */
    updatePersonLocation(id: string, body: PersonLocationUpdateInput): Observable<BoolOutput>;
    /**
     * User with Role list
     * @return OK
     */
    getUserRoles(userID: string): Observable<UserRole[]>;
    /**
     * User Role list
     * @return OK
     */
    getUserRole(userId: string, roleId: string): Observable<UserRole>;
    /**
     * User Role update
     * @return OK
     */
    postUserRole(userId: string, roleId: string): Observable<AssignedBoolOutput>;
    /**
     * User delete
     * @return OK
     */
    deleteUserRole(userId: string, roleId: string): Observable<BoolOutput>;
    /**
     * Role list
     * @return OK
     */
    getRoles(): Observable<Role[]>;
    /**
     * Create Role
     * @param body Cuerpo del mensaje para crear el rol.
     * @return OK
     */
    createRole(body: RoleInput): Observable<IdOutput>;
    /**
     * Role list
     * @return OK
     */
    getRole(id: string): Observable<Role>;
    /**
     * Role update
     * @param body Cuerpo del mensaje para actualizar el rol.
     * @return OK
     */
    updateRole(id: string, body: RoleInput): Observable<BoolOutput>;
    /**
     * Role delete
     * @return OK
     */
    deleteRole(id: string): Observable<BoolOutput>;
    /**
     * role with view list
     * @return OK
     */
    getRoleView(): Observable<RoleView[]>;
    /**
     * User Role update
     * @param body Cuerpo del mensaje para crear el role view.
     * @return OK
     */
    assignmentRoleView(body: RoleViewInput): Observable<IdOutput>;
    /**
     * RoleView update
     * @param body Cuerpo del mensaje para actualizar el role view.
     * @return OK
     */
    updateRoleView(body: RoleViewInput): Observable<BoolOutput>;
    /**
     * User Role list
     * @return OK
     */
    getRoleViewDetail(roleID: string, viewID: string): Observable<UserRole>;
    /**
     * User delete
     * @return OK
     */
    deleteRoleViewDetail(roleID: string, viewID: string): Observable<BoolOutput>;
    /**
     * Module list
     * @return OK
     */
    getModules(): Observable<Module[]>;
    /**
     * Create Module
     * @param body Cuerpo del mensaje para crear el module.
     * @return OK
     */
    createModule(body: ModuleInput): Observable<IdOutput>;
    /**
     * Module list
     * @return OK
     */
    getModule(id: string): Observable<Module>;
    /**
     * Module update
     * @param body Cuerpo del mensaje para actualizar el module.
     * @return OK
     */
    updateModule(id: string, body: ModuleInput): Observable<BoolOutput>;
    /**
     * Module delete
     * @return OK
     */
    deleteModule(id: string): Observable<BoolOutput>;
    /**
     * View list
     * @return OK
     */
    getViews(): Observable<ViewSecondLevel[]>;
    /**
     * Create View
     * @param body Cuerpo del mensaje para crear el view.
     * @return OK
     */
    createView(body: ViewInput): Observable<IdOutput>;
    /**
     * View list
     * @return OK
     */
    getView(id: string): Observable<ViewSecondLevel>;
    /**
     * View update
     * @param body Cuerpo del mensaje para actualizar el view.
     * @return OK
     */
    updateView(id: string, body: ViewInput): Observable<BoolOutput>;
    /**
     * View delete
     * @return OK
     */
    deleteView(id: string): Observable<BoolOutput>;
    /**
     * Properties list
     * @return OK
     */
    getProperties(): Observable<PropertySecondLevel[]>;
    /**
     * Create Property
     * @param body Cuerpo del mensaje para crear el property.
     * @return OK
     */
    createProperty(body: PropertyInput): Observable<IdOutput>;
    /**
     * Property list
     * @return OK
     */
    getProperty(id: string): Observable<PropertySecondLevel>;
    /**
     * Property update
     * @param body Cuerpo del mensaje para actualizar el property.
     * @return OK
     */
    updateProperty(id: string, body: PropertyInput): Observable<BoolOutput>;
    /**
     * Property delete
     * @return OK
     */
    deleteProperty(id: string): Observable<BoolOutput>;
    /**
     * Create Property with location and medias
     * @param body Cuerpo del mensaje para crear el property con location y medias.
     * @param medias_ids (optional)
     * @return OK
     */
    createCompleteProperty(body: PropertyLocationCreateInput, medias_ids?: string | undefined): Observable<IdOutput>;
    /**
     * Update Property with location and medias
     * @param body Cuerpo del mensaje para actualizar el property con location y medias.
     * @param medias_ids (optional)
     * @return OK
     */
    updateCompleteProperty(
        id: string,
        body: PropertyLocationUpdateInput,
        medias_ids?: string | undefined
    ): Observable<BoolOutput>;
    /**
     * Property list
     * @return OK
     */
    getPropertyUserId(id: string): Observable<PropertySecondLevel[]>;
    /**
     * Location list
     * @return OK
     */
    getLocations(): Observable<Location[]>;
    /**
     * Create Location
     * @param body Cuerpo del mensaje para crear el Location.
     * @return OK
     */
    createLocation(body: LocationInput): Observable<IdOutput>;
    /**
     * Location list
     * @return OK
     */
    getLocation(id: string): Observable<Location>;
    /**
     * Location update
     * @param body Cuerpo del mensaje para actualizar el Location.
     * @return OK
     */
    updateLocation(id: string, body: LocationInput): Observable<BoolOutput>;
    /**
     * Location delete
     * @return OK
     */
    deleteLocation(id: string): Observable<BoolOutput>;
    /**
     * Transaction list
     * @param typeProperty (optional) Tipo de propiedad
     * @param rooms (optional) numero de habitaciones
     * @param bathrooms (optional) numero de bathrooms
     * @param minArea (optional) minimo de area
     * @param maxArea (optional) maximo de area
     * @param typeTransaction (optional) Tipo de transaccion
     * @param maxCost (optional) maximo costo
     * @param minCost (optional) minimo costo
     * @param country (optional) pais
     * @param province (optional) provincia
     * @param district (optional) distrito
     * @return OK
     */
    getTransactions(
        typeProperty?: string | undefined,
        rooms?: number | undefined,
        bathrooms?: number | undefined,
        minArea?: number | undefined,
        maxArea?: number | undefined,
        typeTransaction?: string | undefined,
        maxCost?: number | undefined,
        minCost?: number | undefined,
        country?: string | undefined,
        province?: string | undefined,
        district?: string | undefined
    ): Observable<TransactionThirdLevel[]>;
    /**
     * Create Transaction
     * @param body Cuerpo del mensaje para crear el Transaction.
     * @return OK
     */
    createTransaction(body: TransactionInput): Observable<IdOutput>;
    /**
     * Transaction list
     * @return OK
     */
    getTransaction(id: string): Observable<TransactionSecondLevel>;
    /**
     * Transaction update
     * @param body Cuerpo del mensaje para actualizar el Transaction.
     * @return OK
     */
    updateTransaction(id: string, body: TransactionInput): Observable<BoolOutput>;
    /**
     * Transaction delete
     * @return OK
     */
    deleteTransaction(id: string): Observable<BoolOutput>;
    /**
     * Transaction list
     * @return OK
     */
    getTransactionByUser(id: string): Observable<TransactionSecondLevel[]>;
}

@Injectable({
    providedIn: 'root',
})
export class HouseMatch implements IHouseMatch {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : 'http://localhost:8080/v1';
    }

    loginFoo(body: Login, httpContext?: HttpContext): Observable<Token> {
        let url_ = this.baseUrl + '/users/login';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http.post(url_, content_, options_).pipe(
            _observableMergeMap((response_: any) => {
                return blobToText(response_).pipe(
                    _observableMergeMap((_responseText: string) => {
                        let result201: any = null;
                        result201 =
                            _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as Token);
                        return _observableOf(result201);
                    })
                );
            })
        );
    }

    /**
     * Login
     * @param body Cuerpo del mensaje para acceder al sistema.
     * @return OK
     */
    login(body: Login, httpContext?: HttpContext): Observable<Token> {
        let url_ = this.baseUrl + '/users/login';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processLogin(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processLogin(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<Token>;
                        }
                    } else return _observableThrow(response_) as any as Observable<Token>;
                })
            );
    }

    protected processLogin(response: HttpResponseBase): Observable<Token> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    result201 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as Token);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    uploadMediaFoo(file: File): Observable<any> {
        const formData = new FormData();
        formData.append('fileUpload', file);
        return this.http.post('http://167.71.53.173:8080/v1/media/upload', formData);
    }

    /**
     * upload multimedia
     * @param fileUpload (optional)
     * @return OK
     */
    uploadMedia(fileUpload?: FileParameter | undefined, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + '/media/upload';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = new FormData();
        if (fileUpload === null || fileUpload === undefined)
            throw new Error("The parameter 'fileUpload' cannot be null.");
        else content_.append('fileUpload', fileUpload.data, fileUpload.fileName ? fileUpload.fileName : 'fileUpload');

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUploadMedia(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUploadMedia(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<IdOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<IdOutput>;
                })
            );
    }

    protected processUploadMedia(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    result201 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as IdOutput);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * see multimedia
     * @param filename nombre del archivo multimedia
     * @return OK
     */
    seeFiles(filename: string, httpContext?: HttpContext): Observable<FileResponse> {
        let url_ = this.baseUrl + '/media/files/{filename}';
        if (filename === undefined || filename === null) throw new Error("The parameter 'filename' must be defined.");
        url_ = url_.replace('{filename}', encodeURIComponent('' + filename));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'image/jpeg',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processSeeFiles(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processSeeFiles(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<FileResponse>;
                        }
                    } else return _observableThrow(response_) as any as Observable<FileResponse>;
                })
            );
    }

    protected processSeeFiles(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            const contentDisposition = response.headers ? response.headers.get('content-disposition') : undefined;
            let fileNameMatch = contentDisposition
                ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition)
                : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * User list
     * @return OK
     */
    getUsers(httpContext?: HttpContext): Observable<UserSecondLevel[]> {
        let url_ = this.baseUrl + '/users';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetUsers(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetUsers(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UserSecondLevel[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UserSecondLevel[]>;
                })
            );
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UserSecondLevel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UserSecondLevel[]);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Create User
     * @param body Cuerpo del mensaje para crear el usuario.
     * @return OK
     */
    createUser(body: UserInput, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + '/users';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCreateUser(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCreateUser(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<IdOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<IdOutput>;
                })
            );
    }

    protected processCreateUser(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    result201 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as IdOutput);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * User list
     * @return OK
     */
    getUser(id: string, httpContext?: HttpContext): Observable<UserSecondLevel> {
        let url_ = this.baseUrl + '/users/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetUser(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetUser(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UserSecondLevel>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UserSecondLevel>;
                })
            );
    }

    protected processGetUser(response: HttpResponseBase): Observable<UserSecondLevel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UserSecondLevel);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * User update
     * @param body Cuerpo del mensaje para actualizar el usuario.
     * @return OK
     */
    updateUser(id: string, body: UserInput, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/users/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('put', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateUser(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateUser(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * User delete
     * @return OK
     */
    deleteUser(id: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/users/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('delete', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDeleteUser(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDeleteUser(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result204: any = null;
                    result204 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result204);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Users list with roles
     * @return OK
     */
    getUsersWithRoles(httpContext?: HttpContext): Observable<UserWithRoles[]> {
        let url_ = this.baseUrl + '/users/roles';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetUsersWithRoles(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetUsersWithRoles(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UserWithRoles[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UserWithRoles[]>;
                })
            );
    }

    protected processGetUsersWithRoles(response: HttpResponseBase): Observable<UserWithRoles[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UserWithRoles[]);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Person list
     * @return OK
     */
    getPersons(httpContext?: HttpContext): Observable<PersonSecondLevel[]> {
        let url_ = this.baseUrl + '/persons';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetPersons(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetPersons(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<PersonSecondLevel[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<PersonSecondLevel[]>;
                })
            );
    }

    protected processGetPersons(response: HttpResponseBase): Observable<PersonSecondLevel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as PersonSecondLevel[]);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Create Person
     * @param body Cuerpo del mensaje para crear el usuario.
     * @return OK
     */
    createPerson(body: PersonInput, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + '/persons';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCreatePerson(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCreatePerson(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<IdOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<IdOutput>;
                })
            );
    }

    protected processCreatePerson(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    result201 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as IdOutput);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Person list
     * @return OK
     */
    getPerson(id: string, httpContext?: HttpContext): Observable<PersonSecondLevel> {
        let url_ = this.baseUrl + '/persons/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetPerson(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetPerson(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<PersonSecondLevel>;
                        }
                    } else return _observableThrow(response_) as any as Observable<PersonSecondLevel>;
                })
            );
    }

    protected processGetPerson(response: HttpResponseBase): Observable<PersonSecondLevel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as PersonSecondLevel);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Person update
     * @param body Cuerpo del mensaje para actualizar el usuario.
     * @return OK
     */
    updatePerson(id: string, body: PersonInput, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/persons/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('put', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdatePerson(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdatePerson(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processUpdatePerson(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Person delete
     * @return OK
     */
    deletePerson(id: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/persons/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('delete', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDeletePerson(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDeletePerson(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processDeletePerson(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result204: any = null;
                    result204 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result204);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Create Person with location
     * @param body Cuerpo del mensaje para crear el person.
     * @return OK
     */
    createPersonLocation(body: PersonLocationCreateInput, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + '/personsLocations';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCreatePersonLocation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCreatePersonLocation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<IdOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<IdOutput>;
                })
            );
    }

    protected processCreatePersonLocation(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    result201 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as IdOutput);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Update Person with location
     * @param body Cuerpo del mensaje para crear el person.
     * @return OK
     */
    updatePersonLocation(
        id: string,
        body: PersonLocationUpdateInput,
        httpContext?: HttpContext
    ): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/personsLocations/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('put', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdatePersonLocation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdatePersonLocation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processUpdatePersonLocation(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * User with Role list
     * @return OK
     */
    getUserRoles(userID: string, httpContext?: HttpContext): Observable<UserRole[]> {
        let url_ = this.baseUrl + '/userRole/user/{userID}';
        if (userID === undefined || userID === null) throw new Error("The parameter 'userID' must be defined.");
        url_ = url_.replace('{userID}', encodeURIComponent('' + userID));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetUserRoles(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetUserRoles(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UserRole[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UserRole[]>;
                })
            );
    }

    protected processGetUserRoles(response: HttpResponseBase): Observable<UserRole[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as UserRole[]);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * User Role list
     * @return OK
     */
    getUserRole(userId: string, roleId: string, httpContext?: HttpContext): Observable<UserRole> {
        let url_ = this.baseUrl + '/userRole/user/{userId}/role/{roleId}';
        if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
        if (roleId === undefined || roleId === null) throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace('{roleId}', encodeURIComponent('' + roleId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetUserRole(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetUserRole(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UserRole>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UserRole>;
                })
            );
    }

    protected processGetUserRole(response: HttpResponseBase): Observable<UserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as UserRole);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * User Role update
     * @return OK
     */
    postUserRole(userId: string, roleId: string, httpContext?: HttpContext): Observable<AssignedBoolOutput> {
        let url_ = this.baseUrl + '/userRole/user/{userId}/role/{roleId}';
        if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
        if (roleId === undefined || roleId === null) throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace('{roleId}', encodeURIComponent('' + roleId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processPostUserRole(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processPostUserRole(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<AssignedBoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<AssignedBoolOutput>;
                })
            );
    }

    protected processPostUserRole(response: HttpResponseBase): Observable<AssignedBoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    result201 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as AssignedBoolOutput);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * User delete
     * @return OK
     */
    deleteUserRole(userId: string, roleId: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/userRole/user/{userId}/role/{roleId}';
        if (userId === undefined || userId === null) throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace('{userId}', encodeURIComponent('' + userId));
        if (roleId === undefined || roleId === null) throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace('{roleId}', encodeURIComponent('' + roleId));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('delete', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDeleteUserRole(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDeleteUserRole(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processDeleteUserRole(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result204: any = null;
                    result204 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result204);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Role list
     * @return OK
     */
    getRoles(httpContext?: HttpContext): Observable<Role[]> {
        let url_ = this.baseUrl + '/roles';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetRoles(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetRoles(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<Role[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<Role[]>;
                })
            );
    }

    protected processGetRoles(response: HttpResponseBase): Observable<Role[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as Role[]);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Create Role
     * @param body Cuerpo del mensaje para crear el rol.
     * @return OK
     */
    createRole(body: RoleInput, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + '/roles';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCreateRole(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCreateRole(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<IdOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<IdOutput>;
                })
            );
    }

    protected processCreateRole(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    result201 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as IdOutput);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Role list
     * @return OK
     */
    getRole(id: string, httpContext?: HttpContext): Observable<Role> {
        let url_ = this.baseUrl + '/roles/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetRole(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetRole(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<Role>;
                        }
                    } else return _observableThrow(response_) as any as Observable<Role>;
                })
            );
    }

    protected processGetRole(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as Role);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Role update
     * @param body Cuerpo del mensaje para actualizar el rol.
     * @return OK
     */
    updateRole(id: string, body: RoleInput, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/roles/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('put', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateRole(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateRole(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processUpdateRole(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Role delete
     * @return OK
     */
    deleteRole(id: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/roles/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('delete', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDeleteRole(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDeleteRole(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result204: any = null;
                    result204 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result204);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * role with view list
     * @return OK
     */
    getRoleView(httpContext?: HttpContext): Observable<RoleView[]> {
        let url_ = this.baseUrl + '/roleView';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetRoleView(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetRoleView(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<RoleView[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<RoleView[]>;
                })
            );
    }

    protected processGetRoleView(response: HttpResponseBase): Observable<RoleView[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as RoleView[]);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * User Role update
     * @param body Cuerpo del mensaje para crear el role view.
     * @return OK
     */
    assignmentRoleView(body: RoleViewInput, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + '/roleView';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processAssignmentRoleView(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processAssignmentRoleView(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<IdOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<IdOutput>;
                })
            );
    }

    protected processAssignmentRoleView(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    result201 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as IdOutput);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * RoleView update
     * @param body Cuerpo del mensaje para actualizar el role view.
     * @return OK
     */
    updateRoleView(body: RoleViewInput, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/roleView';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('put', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateRoleView(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateRoleView(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processUpdateRoleView(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * User Role list
     * @return OK
     */
    getRoleViewDetail(roleID: string, viewID: string, httpContext?: HttpContext): Observable<UserRole> {
        let url_ = this.baseUrl + '/roleView/role/{roleID}/view/{viewID}';
        if (roleID === undefined || roleID === null) throw new Error("The parameter 'roleID' must be defined.");
        url_ = url_.replace('{roleID}', encodeURIComponent('' + roleID));
        if (viewID === undefined || viewID === null) throw new Error("The parameter 'viewID' must be defined.");
        url_ = url_.replace('{viewID}', encodeURIComponent('' + viewID));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetRoleViewDetail(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetRoleViewDetail(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<UserRole>;
                        }
                    } else return _observableThrow(response_) as any as Observable<UserRole>;
                })
            );
    }

    protected processGetRoleViewDetail(response: HttpResponseBase): Observable<UserRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as UserRole);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * User delete
     * @return OK
     */
    deleteRoleViewDetail(roleID: string, viewID: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/roleView/role/{roleID}/view/{viewID}';
        if (roleID === undefined || roleID === null) throw new Error("The parameter 'roleID' must be defined.");
        url_ = url_.replace('{roleID}', encodeURIComponent('' + roleID));
        if (viewID === undefined || viewID === null) throw new Error("The parameter 'viewID' must be defined.");
        url_ = url_.replace('{viewID}', encodeURIComponent('' + viewID));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('delete', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDeleteRoleViewDetail(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDeleteRoleViewDetail(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processDeleteRoleViewDetail(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result204: any = null;
                    result204 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result204);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Module list
     * @return OK
     */
    getModules(httpContext?: HttpContext): Observable<Module[]> {
        let url_ = this.baseUrl + '/modules';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetModules(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetModules(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<Module[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<Module[]>;
                })
            );
    }

    protected processGetModules(response: HttpResponseBase): Observable<Module[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as Module[]);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Create Module
     * @param body Cuerpo del mensaje para crear el module.
     * @return OK
     */
    createModule(body: ModuleInput, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + '/modules';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCreateModule(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCreateModule(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<IdOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<IdOutput>;
                })
            );
    }

    protected processCreateModule(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    result201 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as IdOutput);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Module list
     * @return OK
     */
    getModule(id: string, httpContext?: HttpContext): Observable<Module> {
        let url_ = this.baseUrl + '/modules/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetModule(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetModule(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<Module>;
                        }
                    } else return _observableThrow(response_) as any as Observable<Module>;
                })
            );
    }

    protected processGetModule(response: HttpResponseBase): Observable<Module> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as Module);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Module update
     * @param body Cuerpo del mensaje para actualizar el module.
     * @return OK
     */
    updateModule(id: string, body: ModuleInput, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/modules/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('put', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateModule(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateModule(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processUpdateModule(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Module delete
     * @return OK
     */
    deleteModule(id: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/modules/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('delete', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDeleteModule(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDeleteModule(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processDeleteModule(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result204: any = null;
                    result204 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result204);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * View list
     * @return OK
     */
    getViews(httpContext?: HttpContext): Observable<ViewSecondLevel[]> {
        let url_ = this.baseUrl + '/views';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetViews(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetViews(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ViewSecondLevel[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ViewSecondLevel[]>;
                })
            );
    }

    protected processGetViews(response: HttpResponseBase): Observable<ViewSecondLevel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as ViewSecondLevel[]);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Create View
     * @param body Cuerpo del mensaje para crear el view.
     * @return OK
     */
    createView(body: ViewInput, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + '/views';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCreateView(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCreateView(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<IdOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<IdOutput>;
                })
            );
    }

    protected processCreateView(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    result201 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as IdOutput);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * View list
     * @return OK
     */
    getView(id: string, httpContext?: HttpContext): Observable<ViewSecondLevel> {
        let url_ = this.baseUrl + '/views/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetView(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetView(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<ViewSecondLevel>;
                        }
                    } else return _observableThrow(response_) as any as Observable<ViewSecondLevel>;
                })
            );
    }

    protected processGetView(response: HttpResponseBase): Observable<ViewSecondLevel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as ViewSecondLevel);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * View update
     * @param body Cuerpo del mensaje para actualizar el view.
     * @return OK
     */
    updateView(id: string, body: ViewInput, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/views/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('put', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateView(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateView(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processUpdateView(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * View delete
     * @return OK
     */
    deleteView(id: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/views/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('delete', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDeleteView(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDeleteView(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processDeleteView(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result204: any = null;
                    result204 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result204);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Properties list
     * @return OK
     */
    getProperties(httpContext?: HttpContext): Observable<PropertySecondLevel[]> {
        let url_ = this.baseUrl + '/properties';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetProperties(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetProperties(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<PropertySecondLevel[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<PropertySecondLevel[]>;
                })
            );
    }

    protected processGetProperties(response: HttpResponseBase): Observable<PropertySecondLevel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as PropertySecondLevel[]);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Create Property
     * @param body Cuerpo del mensaje para crear el property.
     * @return OK
     */
    createProperty(body: PropertyInput, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + '/properties';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCreateProperty(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCreateProperty(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<IdOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<IdOutput>;
                })
            );
    }

    protected processCreateProperty(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    result201 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as IdOutput);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Property list
     * @return OK
     */
    getProperty(id: string, httpContext?: HttpContext): Observable<PropertySecondLevel> {
        let url_ = this.baseUrl + '/properties/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetProperty(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetProperty(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<PropertySecondLevel>;
                        }
                    } else return _observableThrow(response_) as any as Observable<PropertySecondLevel>;
                })
            );
    }

    protected processGetProperty(response: HttpResponseBase): Observable<PropertySecondLevel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as PropertySecondLevel);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Property update
     * @param body Cuerpo del mensaje para actualizar el property.
     * @return OK
     */
    updateProperty(id: string, body: PropertyInput, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/properties/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('put', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateProperty(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateProperty(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processUpdateProperty(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Property delete
     * @return OK
     */
    deleteProperty(id: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/properties/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('delete', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDeleteProperty(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDeleteProperty(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processDeleteProperty(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result204: any = null;
                    result204 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result204);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Create Property with location and medias
     * @param body Cuerpo del mensaje para crear el property con location y medias.
     * @param medias_ids (optional)
     * @return OK
     */
    createCompleteProperty(
        body: PropertyLocationCreateInput,
        medias_ids?: string | undefined,
        httpContext?: HttpContext
    ): Observable<IdOutput> {
        let url_ = this.baseUrl + '/properties/create?';
        if (medias_ids === null) throw new Error("The parameter 'medias_ids' cannot be null.");
        else if (medias_ids !== undefined) url_ += 'medias_ids=' + encodeURIComponent('' + medias_ids) + '&';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCreateCompleteProperty(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCreateCompleteProperty(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<IdOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<IdOutput>;
                })
            );
    }

    protected processCreateCompleteProperty(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    result201 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as IdOutput);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Update Property with location and medias
     * @param body Cuerpo del mensaje para actualizar el property con location y medias.
     * @param medias_ids (optional)
     * @return OK
     */
    updateCompleteProperty(
        id: string,
        body: PropertyLocationUpdateInput,
        medias_ids?: string | undefined,
        httpContext?: HttpContext
    ): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/properties/update/{id}?';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        if (medias_ids === null) throw new Error("The parameter 'medias_ids' cannot be null.");
        else if (medias_ids !== undefined) url_ += 'medias_ids=' + encodeURIComponent('' + medias_ids) + '&';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('put', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateCompleteProperty(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateCompleteProperty(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processUpdateCompleteProperty(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Property list
     * @return OK
     */
    getPropertyUserId(id: string, httpContext?: HttpContext): Observable<PropertySecondLevel[]> {
        let url_ = this.baseUrl + '/properties/user/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetPropertyUserId(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetPropertyUserId(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<PropertySecondLevel[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<PropertySecondLevel[]>;
                })
            );
    }

    protected processGetPropertyUserId(response: HttpResponseBase): Observable<PropertySecondLevel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as PropertySecondLevel[]);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Location list
     * @return OK
     */
    getLocations(httpContext?: HttpContext): Observable<Location[]> {
        let url_ = this.baseUrl + '/locations';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetLocations(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetLocations(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<Location[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<Location[]>;
                })
            );
    }

    protected processGetLocations(response: HttpResponseBase): Observable<Location[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as Location[]);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Create Location
     * @param body Cuerpo del mensaje para crear el Location.
     * @return OK
     */
    createLocation(body: LocationInput, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + '/locations';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCreateLocation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCreateLocation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<IdOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<IdOutput>;
                })
            );
    }

    protected processCreateLocation(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    result201 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as IdOutput);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Location list
     * @return OK
     */
    getLocation(id: string, httpContext?: HttpContext): Observable<Location> {
        let url_ = this.baseUrl + '/locations/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetLocation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetLocation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<Location>;
                        }
                    } else return _observableThrow(response_) as any as Observable<Location>;
                })
            );
    }

    protected processGetLocation(response: HttpResponseBase): Observable<Location> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as Location);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Location update
     * @param body Cuerpo del mensaje para actualizar el Location.
     * @return OK
     */
    updateLocation(id: string, body: LocationInput, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/locations/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('put', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateLocation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateLocation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processUpdateLocation(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Location delete
     * @return OK
     */
    deleteLocation(id: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/locations/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('delete', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDeleteLocation(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDeleteLocation(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processDeleteLocation(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result204: any = null;
                    result204 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result204);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Transaction list
     * @param typeProperty (optional) Tipo de propiedad
     * @param rooms (optional) numero de habitaciones
     * @param bathrooms (optional) numero de bathrooms
     * @param minArea (optional) minimo de area
     * @param maxArea (optional) maximo de area
     * @param typeTransaction (optional) Tipo de transaccion
     * @param maxCost (optional) maximo costo
     * @param minCost (optional) minimo costo
     * @param country (optional) pais
     * @param province (optional) provincia
     * @param district (optional) distrito
     * @return OK
     */
    getTransactions(
        typeProperty?: string | undefined,
        rooms?: number | undefined,
        bathrooms?: number | undefined,
        minArea?: number | undefined,
        maxArea?: number | undefined,
        typeTransaction?: string | undefined,
        maxCost?: number | undefined,
        minCost?: number | undefined,
        country?: string | undefined,
        province?: string | undefined,
        district?: string | undefined,
        httpContext?: HttpContext
    ): Observable<TransactionThirdLevel[]> {
        let url_ = this.baseUrl + '/transactions?';
        if (typeProperty === null) throw new Error("The parameter 'typeProperty' cannot be null.");
        else if (typeProperty !== undefined) url_ += 'typeProperty=' + encodeURIComponent('' + typeProperty) + '&';
        if (rooms === null) throw new Error("The parameter 'rooms' cannot be null.");
        else if (rooms !== undefined) url_ += 'rooms=' + encodeURIComponent('' + rooms) + '&';
        if (bathrooms === null) throw new Error("The parameter 'bathrooms' cannot be null.");
        else if (bathrooms !== undefined) url_ += 'bathrooms=' + encodeURIComponent('' + bathrooms) + '&';
        if (minArea === null) throw new Error("The parameter 'minArea' cannot be null.");
        else if (minArea !== undefined) url_ += 'minArea=' + encodeURIComponent('' + minArea) + '&';
        if (maxArea === null) throw new Error("The parameter 'maxArea' cannot be null.");
        else if (maxArea !== undefined) url_ += 'maxArea=' + encodeURIComponent('' + maxArea) + '&';
        if (typeTransaction === null) throw new Error("The parameter 'typeTransaction' cannot be null.");
        else if (typeTransaction !== undefined)
            url_ += 'typeTransaction=' + encodeURIComponent('' + typeTransaction) + '&';
        if (maxCost === null) throw new Error("The parameter 'maxCost' cannot be null.");
        else if (maxCost !== undefined) url_ += 'maxCost=' + encodeURIComponent('' + maxCost) + '&';
        if (minCost === null) throw new Error("The parameter 'minCost' cannot be null.");
        else if (minCost !== undefined) url_ += 'minCost=' + encodeURIComponent('' + minCost) + '&';
        if (country === null) throw new Error("The parameter 'country' cannot be null.");
        else if (country !== undefined) url_ += 'country=' + encodeURIComponent('' + country) + '&';
        if (province === null) throw new Error("The parameter 'province' cannot be null.");
        else if (province !== undefined) url_ += 'province=' + encodeURIComponent('' + province) + '&';
        if (district === null) throw new Error("The parameter 'district' cannot be null.");
        else if (district !== undefined) url_ += 'district=' + encodeURIComponent('' + district) + '&';
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetTransactions(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetTransactions(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<TransactionThirdLevel[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<TransactionThirdLevel[]>;
                })
            );
    }

    protected processGetTransactions(response: HttpResponseBase): Observable<TransactionThirdLevel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as TransactionThirdLevel[]);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Create Transaction
     * @param body Cuerpo del mensaje para crear el Transaction.
     * @return OK
     */
    createTransaction(body: TransactionInput, httpContext?: HttpContext): Observable<IdOutput> {
        let url_ = this.baseUrl + '/transactions';
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('post', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processCreateTransaction(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processCreateTransaction(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<IdOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<IdOutput>;
                })
            );
    }

    protected processCreateTransaction(response: HttpResponseBase): Observable<IdOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 201) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result201: any = null;
                    result201 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as IdOutput);
                    return _observableOf(result201);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Transaction list
     * @return OK
     */
    getTransaction(id: string, httpContext?: HttpContext): Observable<TransactionSecondLevel> {
        let url_ = this.baseUrl + '/transactions/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetTransaction(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetTransaction(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<TransactionSecondLevel>;
                        }
                    } else return _observableThrow(response_) as any as Observable<TransactionSecondLevel>;
                })
            );
    }

    protected processGetTransaction(response: HttpResponseBase): Observable<TransactionSecondLevel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as TransactionSecondLevel);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Transaction update
     * @param body Cuerpo del mensaje para actualizar el Transaction.
     * @return OK
     */
    updateTransaction(id: string, body: TransactionInput, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/transactions/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                'Content-Type': 'application/json',
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('put', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processUpdateTransaction(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processUpdateTransaction(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processUpdateTransaction(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Transaction delete
     * @return OK
     */
    deleteTransaction(id: string, httpContext?: HttpContext): Observable<BoolOutput> {
        let url_ = this.baseUrl + '/transactions/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('delete', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processDeleteTransaction(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processDeleteTransaction(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<BoolOutput>;
                        }
                    } else return _observableThrow(response_) as any as Observable<BoolOutput>;
                })
            );
    }

    protected processDeleteTransaction(response: HttpResponseBase): Observable<BoolOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result204: any = null;
                    result204 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BoolOutput);
                    return _observableOf(result204);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }

    /**
     * Transaction list
     * @return OK
     */
    getTransactionByUser(id: string, httpContext?: HttpContext): Observable<TransactionSecondLevel[]> {
        let url_ = this.baseUrl + '/transactions/user/{id}';
        if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace('{id}', encodeURIComponent('' + id));
        url_ = url_.replace(/[?&]$/, '');

        let options_: any = {
            observe: 'response',
            responseType: 'blob',
            context: httpContext,
            headers: new HttpHeaders({
                Accept: 'application/json',
            }),
        };

        return this.http
            .request('get', url_, options_)
            .pipe(
                _observableMergeMap((response_: any) => {
                    return this.processGetTransactionByUser(response_);
                })
            )
            .pipe(
                _observableCatch((response_: any) => {
                    if (response_ instanceof HttpResponseBase) {
                        try {
                            return this.processGetTransactionByUser(response_ as any);
                        } catch (e) {
                            return _observableThrow(e) as any as Observable<TransactionSecondLevel[]>;
                        }
                    } else return _observableThrow(response_) as any as Observable<TransactionSecondLevel[]>;
                })
            );
    }

    protected processGetTransactionByUser(response: HttpResponseBase): Observable<TransactionSecondLevel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse
                ? response.body
                : (response as any).error instanceof Blob
                ? (response as any).error
                : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result200: any = null;
                    result200 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as TransactionSecondLevel[]);
                    return _observableOf(result200);
                })
            );
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result400: any = null;
                    result400 =
                        _responseText === '' ? null : (JSON.parse(_responseText, this.jsonParseReviver) as BadRequest);
                    return throwException('BAD_REQUEST', status, _responseText, _headers, result400);
                })
            );
        } else if (status === 422) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result422: any = null;
                    result422 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnprocessableEntity);
                    return throwException('UNPROCESSABLE_ENTITY', status, _responseText, _headers, result422);
                })
            );
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    let result500: any = null;
                    result500 =
                        _responseText === ''
                            ? null
                            : (JSON.parse(_responseText, this.jsonParseReviver) as UnexpectedError);
                    return throwException('INTERNAL_SERVER_ERROR', status, _responseText, _headers, result500);
                })
            );
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(
                _observableMergeMap((_responseText: string) => {
                    return throwException('An unexpected server error occurred.', status, _responseText, _headers);
                })
            );
        }
        return _observableOf(null as any);
    }
}

export interface Login {
    /** Usuario o nick. */
    user?: string;
    /** Email del usuario */
    email?: string;
    /** Password del usuario. */
    password?: string;

    [key: string]: any;
}

export interface User {
    /** ID del usuario. */
    id?: string;
    /** Usuario o nick. */
    user?: string;
    /** Password del usuario. */
    password?: string;
    /** Email del usuario */
    email?: string;
    /** Tema de visualizacion del usuario */
    theme?: string;
    /** ID del person. */
    person_id?: string;

    [key: string]: any;
}

export interface UserSecondLevel {
    /** ID del usuario. */
    id?: string;
    /** Usuario o nick. */
    user?: string;
    /** Password del usuario. */
    password?: string;
    /** Email del usuario */
    email?: string;
    /** Tema de visualizacion del usuario */
    theme?: string;
    person?: Person;

    [key: string]: any;
}

export interface UserInput {
    /** Usuario o nick. */
    user?: string;
    /** Password del usuario. */
    password?: string;
    /** Email del usuario */
    email?: string;
    /** Tema de visualizacion del usuario */
    theme?: string;
    /** ID del person. */
    person_id?: string;

    [key: string]: any;
}

export interface UserWithRoles {
    /** ID del usuario. */
    id?: string;
    /** Usuario o nick. */
    user?: string;
    /** Password del usuario. */
    password?: string;
    /** Email del usuario */
    email?: string;
    /** Tema de visualizacion del usuario */
    theme?: string;
    /** ID del person. */
    person_id?: string;
    roles?: Role[];

    [key: string]: any;
}

export interface Person {
    /** ID del person. */
    id?: string;
    /** document_type o nick. */
    document_type?: string;
    /** document del person. */
    document?: string;
    /** names del person */
    names?: string;
    /** lastname del person */
    lastname?: string;
    /** m_lastname del person */
    m_lastname?: string;
    /** phone o nick. */
    phone?: string;
    /** gender del person. */
    gender?: string;
    /** marital_status del person */
    marital_status?: string;
    /** date_birth del person */
    date_birth?: string;
    /** id de la photo person. */
    photo?: string;
    /** id del location person. */
    location_id?: string;

    [key: string]: any;
}

export interface PersonSecondLevel {
    /** ID del person. */
    id?: string;
    /** document_type o nick. */
    document_type?: string;
    /** document del person. */
    document?: string;
    /** names del person */
    names?: string;
    /** lastname del person */
    lastname?: string;
    /** m_lastname del person */
    m_lastname?: string;
    /** phone o nick. */
    phone?: string;
    /** gender del person. */
    gender?: string;
    /** marital_status del person */
    marital_status?: string;
    /** date_birth del person */
    date_birth?: string;
    /** id de la photo person. */
    photo?: string;
    location_person?: Location;

    [key: string]: any;
}

export interface PersonInput {
    /** document_type o nick. */
    document_type?: string;
    /** document del person. */
    document?: string;
    /** names del person */
    names?: string;
    /** lastnames del person */
    lastname?: string;
    /** m_lastname del person */
    m_lastname?: string;
    /** phone o nick. */
    phone?: string;
    /** gender del person. */
    gender?: string;
    /** marital_status del person */
    marital_status?: string;
    /** date_birth del person */
    date_birth?: string;
    /** id de la photo. */
    photo?: string;
    /** id del location person. */
    location_id?: string;

    [key: string]: any;
}

export interface PersonWithoutLocation {
    /** document_type o nick. */
    document_type?: string;
    /** document del person. */
    document?: string;
    /** names del person */
    names?: string;
    /** lastnames del person */
    lastname?: string;
    /** m_lastname del person */
    m_lastname?: string;
    /** phone o nick. */
    phone?: string;
    /** gender del person. */
    gender?: string;
    /** marital_status del person */
    marital_status?: string;
    /** date_birth del person */
    date_birth?: string;
    /** id de la photo. */
    photo?: string;

    [key: string]: any;
}

export interface PersonLocationCreateInput {
    person?: PersonWithoutLocation;
    location?: LocationInput;

    [key: string]: any;
}

export interface PersonLocationUpdateInput {
    person?: PersonInput;
    location?: LocationInput;

    [key: string]: any;
}

export interface Module {
    /** id del modulo. */
    id?: string;
    /** name. */
    name?: string;
    /** description del modulo. */
    description?: string;
    /** icon del modulo */
    icon?: string;
    /** order de visualizacion del modulo */
    order?: number;

    [key: string]: any;
}

export interface ModuleInput {
    /** name. */
    name?: string;
    /** description del modulo. */
    description?: string;
    /** icon del modulo */
    icon?: string;
    /** order de visualizacion del modulo */
    order?: number;

    [key: string]: any;
}

export interface UserRole {
    user?: User;
    role?: Role;

    [key: string]: any;
}

export interface UserRoleInput {
    /** id del user. */
    user_id?: string;
    /** id del role. */
    role_id?: string;

    [key: string]: any;
}

export interface Role {
    /** id del role. */
    id?: string;
    /** name. */
    name?: string;
    /** description del role. */
    description?: string;
    /** order de visualizacion del role */
    order?: number;

    [key: string]: any;
}

export interface RoleInput {
    /** name. */
    name?: string;
    /** description del role. */
    description?: string;
    /** order de visualizacion del role */
    order?: number;

    [key: string]: any;
}

export interface RoleView {
    role?: Role;
    view?: View;
    /** viewOrder. */
    viewOrder?: string;
    /** viewPosition del view. */
    viewPosition?: string;

    [key: string]: any;
}

export interface RoleViewInput {
    /** id del role. */
    role_id?: string;
    /** id de view. */
    view_id?: string;
    /** viewOrder. */
    viewOrder?: string;
    /** viewPosition del view. */
    viewPosition?: string;

    [key: string]: any;
}

export interface View {
    /** id del view. */
    id?: string;
    /** id del module. */
    module_id?: string;
    /** name. */
    name?: string;
    /** description del view. */
    description?: string;
    /** url de visualizacion del view */
    url?: string;
    /** icon del view */
    icon?: string;

    [key: string]: any;
}

export interface ViewSecondLevel {
    /** id del view. */
    id?: string;
    module?: Module;
    /** name. */
    name?: string;
    /** description del view. */
    description?: string;
    /** url de visualizacion del view */
    url?: string;
    /** icon del view */
    icon?: string;

    [key: string]: any;
}

export interface ViewInput {
    /** id del module. */
    module_id?: string;
    /** name. */
    name?: string;
    /** description del view. */
    description?: string;
    /** url de visualizacion del view */
    url?: string;
    /** icon del view */
    icon?: string;

    [key: string]: any;
}

export interface Location {
    /** ID del Location. */
    id?: string;
    /** Country. */
    country?: string;
    /** city. */
    city?: string;
    /** province */
    province?: string;
    /** district */
    district?: string;
    /** address del person */
    address?: string;
    /** lat */
    lat?: number;
    /** long */
    long?: number;

    [key: string]: any;
}

export interface LocationInput {
    /** Country. */
    country?: string;
    /** city. */
    city?: string;
    /** province */
    province?: string;
    /** district */
    district?: string;
    /** address */
    address?: string;
    /** lat */
    lat?: number;
    /** long */
    long?: number;

    [key: string]: any;
}

export interface Property {
    /** id del property. */
    id?: string;
    /** id del usuario. */
    user_id?: string;
    /** id del usuario. */
    location_id?: string;
    /** description del property. */
    description?: string;
    /** type del property */
    type?: string;
    /** length del property */
    length?: number;
    /** width del property */
    width?: number;
    /** area del property */
    area?: number;
    /** floor del property */
    floor?: number;
    /** number of floors del property */
    number_of_floor?: number;
    /** number of rooms del property */
    rooms?: number;
    /** number of bathrooms del property */
    bathrooms?: number;
    /** number of yard del property */
    yard?: number;
    /** number of terrace del property */
    terrace?: number;
    /** number of living_room del property */
    living_room?: number;
    /** number of laundry_room del property */
    laundry_room?: number;
    /** number of kitchen del property */
    kitchen?: number;
    /** number of garage del property */
    garage?: number;

    [key: string]: any;
}

export interface PropertySecondLevel {
    /** id del property. */
    id?: string;
    user?: User;
    location?: Location;
    /** description del property. */
    description?: string;
    /** type del property */
    type?: string;
    /** length del property */
    length?: number;
    /** width del property */
    width?: number;
    /** area del property */
    area?: number;
    /** floor del property */
    floor?: number;
    /** number of floors del property */
    number_of_floor?: number;
    /** number of rooms del property */
    rooms?: number;
    /** number of bathrooms del property */
    bathrooms?: number;
    /** number of yard del property */
    yard?: number;
    /** number of terrace del property */
    terrace?: number;
    /** number of living_room del property */
    living_room?: number;
    /** number of laundry_room del property */
    laundry_room?: number;
    /** number of kitchen del property */
    kitchen?: number;
    /** number of garage del property */
    garage?: number;

    [key: string]: any;
}

export interface PropertyWithoutUserSecondLevel {
    /** id del property. */
    id?: string;
    /** id del usuario. */
    user_id?: string;
    location?: Location;
    /** description del property. */
    description?: string;
    /** type del property */
    type?: string;
    /** length del property */
    length?: number;
    /** width del property */
    width?: number;
    /** area del property */
    area?: number;
    /** floor del property */
    floor?: number;
    /** number of floors del property */
    number_of_floor?: number;
    /** number of rooms del property */
    rooms?: number;
    /** number of bathrooms del property */
    bathrooms?: number;
    /** number of yard del property */
    yard?: number;
    /** number of terrace del property */
    terrace?: number;
    /** number of living_room del property */
    living_room?: number;
    /** number of laundry_room del property */
    laundry_room?: number;
    /** number of kitchen del property */
    kitchen?: number;
    /** number of garage del property */
    garage?: number;

    [key: string]: any;
}

export interface PropertyInput {
    /** id del usuario. */
    user_id?: string;
    /** id del usuario. */
    location_id?: string;
    /** description del property. */
    description?: string;
    /** type del property */
    type?: string;
    /** length del property */
    length?: number;
    /** width del property */
    width?: number;
    /** area del property */
    area?: number;
    /** floor del property */
    floor?: number;
    /** number of floors del property */
    number_of_floor?: number;
    /** number of rooms del property */
    rooms?: number;
    /** number of bathrooms del property */
    bathrooms?: number;
    /** number of yard del property */
    yard?: number;
    /** number of terrace del property */
    terrace?: number;
    /** number of living_room del property */
    living_room?: number;
    /** number of laundry_room del property */
    laundry_room?: number;
    /** number of kitchen del property */
    kitchen?: number;
    /** number of garage del property */
    garage?: number;

    [key: string]: any;
}

export interface PropertyLocationCreateInput {
    property?: PropertyWithoutLocation;
    location?: LocationInput;

    [key: string]: any;
}

export interface PropertyWithoutLocation {
    /** id del usuario. */
    user_id?: string;
    /** description del property. */
    description?: string;
    /** type del property */
    type?: string;
    /** length del property */
    length?: number;
    /** width del property */
    width?: number;
    /** area del property */
    area?: number;
    /** floor del property */
    floor?: number;
    /** number of floors del property */
    number_of_floor?: number;
    /** number of rooms del property */
    rooms?: number;
    /** number of bathrooms del property */
    bathrooms?: number;
    /** number of yard del property */
    yard?: number;
    /** number of terrace del property */
    terrace?: number;
    /** number of living_room del property */
    living_room?: number;
    /** number of laundry_room del property */
    laundry_room?: number;
    /** number of kitchen del property */
    kitchen?: number;
    /** number of garage del property */
    garage?: number;

    [key: string]: any;
}

export interface PropertyLocationUpdateInput {
    property?: PropertyInput;
    location?: LocationInput;

    [key: string]: any;
}

export interface Token {
    /** Token User. */
    token?: string;

    [key: string]: any;
}

export interface TransactionSecondLevel {
    /** id del transaction. */
    id?: string;
    property?: Property;
    /** cost del transaction. */
    cost?: number;
    /** currency del transaction. */
    currency?: string;
    /** date_vip del transaction */
    date_vip?: string;
    /** date_post del transaction */
    date_post?: string;
    /** date_update del transaction */
    date_update?: string;
    /** available del transaction */
    available?: boolean;
    /** type del transaction */
    type?: string;
    /** date_start del transaction */
    date_start?: string;
    /** date_end del transaction */
    date_end?: string;

    [key: string]: any;
}

export interface TransactionThirdLevel {
    /** id del transaction. */
    id?: string;
    property?: PropertyWithoutUserSecondLevel;
    /** cost del transaction. */
    cost?: number;
    /** currency del transaction. */
    currency?: string;
    /** date_vip del transaction */
    date_vip?: string;
    /** date_post del transaction */
    date_post?: string;
    /** date_update del transaction */
    date_update?: string;
    /** available del transaction */
    available?: boolean;
    /** type del transaction */
    type?: string;
    /** date_start del transaction */
    date_start?: string;
    /** date_end del transaction */
    date_end?: string;

    [key: string]: any;
}

export interface TransactionInput {
    /** id del transaction. */
    property_id?: string;
    /** cost del transaction. */
    cost?: number;
    /** currency del transaction. */
    currency?: string;
    /** date_vip del transaction */
    date_vip?: string;
    /** date_post del transaction */
    date_post?: string;
    /** date_update del transaction */
    date_update?: string;
    /** available del transaction */
    available?: boolean;
    /** type del transaction */
    type?: string;
    /** date_start del transaction */
    date_start?: string;
    /** date_end del transaction */
    date_end?: string;

    [key: string]: any;
}

export interface IdOutput {
    /** ID. */
    id?: string;

    [key: string]: any;
}

export interface BoolOutput {
    /** boolean response. */
    updated?: boolean;

    [key: string]: any;
}

export interface AssignedBoolOutput {
    /** boolean response. */
    assigned?: boolean;

    [key: string]: any;
}

/** Object of response error */
export interface UnexpectedError {
    /** message of response */
    error?: string;

    [key: string]: any;
}

/** Object of response error */
export interface BadRequest {
    /** custom code of response */
    error?: string;

    [key: string]: any;
}

/** Object of response error */
export interface UnprocessableEntity {
    /** custom code of response */
    error?: string;

    [key: string]: any;
}

/** Object of response error */
export interface EntityDetail {
    /** field with error */
    field?: string;
    /** custom code of response */
    issue?: string;
    /** error details of field */
    description?: string;

    [key: string]: any;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result?: any
): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next('');
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = (event) => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
